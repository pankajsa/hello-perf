/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package co.eventmesh.samples.helloperf;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Configuration {
	static private Logger logger = LoggerFactory.getLogger(Configuration.class);

	private static Options options = optionsBuilder();
	private static HashMap<String, String> hmap = new HashMap<String,String>();
	
	public static final int MESSAGE_SIZE = 1024;
	public static final int PUBLISH_THREAD_COUNT = 1;
	public static final int CONSUME_THREAD_COUNT = 1;
	public static final int RESPOND_THREAD_COUNT = 1;
	public static final String MODE = "direct";

//	public static final int PUBLISH_COUNT = 1;
//	public static final int THREAD_COUNT = 1;
//	public static final int CONSUMER_THREAD_COUNT = 2;
	

    public static void Usage() {
    	System.err.println("Usage:");
    	// automatically generate the help statement
    	HelpFormatter formatter = new HelpFormatter();
    	formatter.printHelp( "App", options );
    	
    }
    
    
    private static Options optionsBuilder() {
    	Options options = new Options();

    	options.addOption(Option.builder("h")
    			.required(true)
    			.desc("hostname of the Solace pubsub+")
    			.longOpt("hostname")
    			.numberOfArgs(1)
    			.build()); 	
    	options.addOption(Option.builder("v")
    			.required(true)
    			.desc("vpn name")
    			.longOpt("vpn")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("u")
    			.required(false)
    			.desc("username")
    			.longOpt("username")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("p")
    			.required(false)
    			.desc("password")
    			.longOpt("password")
    			.numberOfArgs(1)
    			.build());


    	options.addOption(Option.builder("c")
    			.required(true)
    			.desc("number of messages to publish per thread")
    			.longOpt("msgcount")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("z")
    			.required(false)
    			.desc("message size in bytes")
    			.longOpt("messagesize")
    			.numberOfArgs(1)
    			.build());


    	options.addOption(Option.builder("pt")
    			.required(true)
    			.desc("publish topic")
    			.longOpt("publishtopic")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("cq")
    			.required(true)
    			.desc("consume queue")
    			.longOpt("consumequeue")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("rt")
    			.required(true)
    			.desc("respond topic")
    			.longOpt("respondtopic")
    			.numberOfArgs(1)
    			.build());


    	options.addOption(Option.builder("pm")
    			.required(false)
    			.desc("publish mode: direct or persistent")
    			.longOpt("publishmode")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("rm")
    			.required(false)
    			.desc("respond mode: direct or persistent")
    			.longOpt("respondmode")
    			.numberOfArgs(1)
    			.build());

    	
    	
    	options.addOption(Option.builder("ptc")
    			.required(false)
    			.desc("publish thread count")
    			.longOpt("publishthreads")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("ctc")
    			.required(false)
    			.desc("consume thread count")
    			.longOpt("consumethreads")
    			.numberOfArgs(1)
    			.build());
    	options.addOption(Option.builder("rtc")
    			.required(false)
    			.desc("publish thread count")
				.longOpt("respondthreads")
    			.numberOfArgs(1)
    			.build());


    	options.addOption(Option.builder("pp")
    			.required(false)
    			.desc("enable publish step")
    			.longOpt("publish")
    			.numberOfArgs(0)
    			.build());
    	options.addOption(Option.builder("cc")
    			.required(false)
    			.desc("enable consume step")
    			.longOpt("consume")
    			.numberOfArgs(0)
    			.build());
    	options.addOption(Option.builder("rr")
    			.required(false)
    			.desc("enable respond step")
    			.longOpt("respond")
    			.numberOfArgs(0)
    			.build());


    	return(options);
    	
    }
    
    private static void updateArgument(String key, CommandLine cmd) {
    	String val = null;

    	if (cmd.hasOption(key)) {
    		val = cmd.getOptionValue(key) != null ? cmd.getOptionValue(key):"1";
    	}
    	
    	if (val == null) {
        	if (key == "username")
        		val = "default";
        	else if (key == "messagesize")
        		val = Integer.toString(MESSAGE_SIZE);
        	else if (key == "publishthreads")
        		val = Integer.toString(PUBLISH_THREAD_COUNT);
        	else if (key == "consumethreads")
        		val = Integer.toString(CONSUME_THREAD_COUNT);
        	else if (key == "respondthreads")
        		val = Integer.toString(RESPOND_THREAD_COUNT);
        	else if (key == "messagesize")
        		val = Integer.toString(MESSAGE_SIZE);
        	else if (key == "publishmode")
        		val = MODE;
        	else if (key == "respondmode")
        		val = MODE;
        	

    	}
    	hmap.put(key, val);
    }
    
    public static HashMap<String, String> setupDefaults(String[] args) { 
    	
    	CommandLineParser parser = new DefaultParser();
    	CommandLine cmd;
		try {
			cmd = parser.parse( options, args);
			
			List<String> array = new ArrayList<>(Arrays.asList(
					"hostname"
					, "vpn"
					, "username"
					, "password"
					, "msgcount"
					, "messagesize"
					, "publishtopic"
					, "consumequeue"
					, "respondtopic"
					, "publishthreads"
					, "consumethreads"
					, "respondthreads"
					, "publish"
					, "consume"
					, "respond"
					, "publishmode"
					, "respondmode"
					));
			array.forEach(s -> updateArgument(s, cmd));
			
	    	return(hmap);
		} catch (ParseException e) {
    		logger.error("Error in command line arguments. " + e.getMessage());
    		Usage();
    		System.exit(1);
		}
		throw new RuntimeException("Unknown Error");
    	
    }

    public static HashMap<String, String> getDefaults() { 
    	return hmap;
    	
    }

}
